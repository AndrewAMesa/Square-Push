{"ast":null,"code":"import { config_4x4, config_5x5, config_6x6 } from \"./config\";\n\n// store configurations\nconst configs = [config_5x5, config_4x4, config_6x6];\n\n/* represents a square on the board */\nexport class Square {\n  constructor(row, column) {\n    this.row = row;\n    this.column = column;\n  }\n}\n\n/* represents the game board */\nexport class Board {\n  // size is the size of the board\n  // config is the configuration of the board\n  constructor(size, config) {\n    this.size = size; // size of game board\n    this.config = config; // configuration of game board\n\n    this.grid = Array.from(Array(size), () => new Array(size)); // 2D array representing game board\n\n    this.ninjaSeRow = this.config.ninjaRow - 1; // Row that the top-left corner of ninja-se is on\n    this.ninjaSeColumn = this.config.ninjaColumn.toLowerCase().charCodeAt(0) - 97; // Column that the top-left corner of ninja-se is on\n\n    //sets up base board\n    for (let r = 0; r < size; r++) {\n      for (let c = 0; c < size; c++) {\n        this.grid[r][c] = new Square(r, c);\n        this.grid[r][c].color = 'white';\n      }\n    }\n\n    //adds colored squares to board from config file\n    for (let i = 0; i < this.config.initial.length; i++) {\n      let row = this.config.initial[i][\"row\"] - 1;\n      let column = this.config.initial[i][\"column\"].toLowerCase().charCodeAt(0) - 97;\n      let color = this.config.initial[i][\"color\"];\n      this.grid[row][column].color = color;\n    }\n\n    // how you access a square by its [row][column] location\n    // this.grid[2][4]\n  }\n\n  /* return true if ninja-se and a square are at the same spot, or if two squares are at the same spot */\n  isOverlappedWithSquare(row, column) {\n    if (this.grid[row][column].color != 'white') {\n      return true;\n    }\n    return false;\n  }\n\n  /* return true if ninja-se can move the intended direction, ninja-se cannot wrap around the board */\n  isValidMove(verticalChange, horizontalChange) {\n    if (this.ninjaSeRow + verticalChange >= 0 && this.ninjaSeRow + verticalChange < this.size - 1) {\n      //Prevents Ninja-se from moving vertically off the board\n      if (this.ninjaSeColumn + horizontalChange >= 0 && this.ninjaSeColumn + horizontalChange < this.size - 1) {\n        //Prevents Ninja-se from moving horizontally off the board\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /* return true if all colored squares are off the board (game is won) */\n  isWon() {\n    for (let r = 0; r < this.size; r++) {\n      for (let c = 0; c < this.size; c++) {\n        if (this.grid[r][c].color != 'white') {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}\n\n/* represents the the logic for the entire model (board, counters, and butttons) */\nexport default class Model {\n  // info is going to be JSON-encoded puzzle\n\n  // 'which' is an integer 0..1..2 which selects configuration you can use\n  constructor(which) {\n    this.config = configs[which]; // the configuration selected\n    this.score = 0; // integer value for the score value\n    this.count = 0; // integer value for the count value\n    this.won = false; // boolean value on if the game is won\n\n    this.size = Number(this.config.numColumns); // size of the board\n    this.board = new Board(this.size, this.config); // game board within the model\n  }\n\n  /* changes the configuration of the board and resets appropriate values */\n  changeConfiguration(which) {\n    this.config = configs[which];\n    this.won = false;\n    this.size = Number(this.config.numColumns);\n    this.board = new Board(this.size, this.config);\n    this.count = 0;\n    this.score = 0;\n  }\n\n  /* resets the configuration of the board to initial layout and resets appropriate values */\n  resetConfiguration() {\n    this.won = false;\n    this.size = Number(this.config.numColumns);\n    this.board = new Board(this.size, this.config);\n    this.count = 0;\n    this.score = 0;\n  }\n\n  /* shifts the squares on the board when they are moved by ninja-se */\n  moveSquares(verticalChange, horizontalChange, ninjaSeRow, ninjaSeColumn) {\n    if (this.board.isOverlappedWithSquare(ninjaSeRow, ninjaSeColumn)) {\n      let newRow = ninjaSeRow + verticalChange; //represents the new row of the item (ninja-se or square) after the vertical change applied to it\n      let newColumn = ninjaSeColumn + horizontalChange; //represents the new column of the item (ninja-se or square) after the horizontal change applied to it\n\n      if (newRow == -1) {\n        // wraps a square from the top to the bottom of the board\n        newRow = this.size - 1;\n      } else if (newRow == this.size) {\n        // wraps a square from the bottom to the top of the board\n        newRow = 0;\n      } else if (newColumn == -1) {\n        // wraps a square from the left to the right of the board\n        newColumn = this.size - 1;\n      } else if (newColumn == this.size) {\n        // wraps a sqaure from the right to the left of the board\n        newColumn = 0;\n      }\n\n      // 1) if the shifted square overlaps with a square we then recursively move the square that is now being overlapped by the vertical and horizontal change\n      // 2) once the square finds a location that is empty we then stop the recursion and place that square on the board \n      // 3) then we move backwards through the recursion placing all the other squares on the appropriate spots\n      if (this.board.isOverlappedWithSquare(newRow, newColumn)) {\n        this.moveSquares(verticalChange, horizontalChange, newRow, newColumn);\n      }\n\n      // placing squares on their new spots, and removing them form their old spots\n      this.board.grid[newRow][newColumn].color = this.board.grid[ninjaSeRow][ninjaSeColumn].color;\n      this.board.grid[ninjaSeRow][ninjaSeColumn].color = 'white';\n      this.score++;\n    }\n  }\n\n  /* parses whole 2D array looking for 2x2 blocks of the same color and removing them */\n  removeBlocks() {\n    let tempChange = false;\n    for (let r = 0; r < this.size - 1; r++) {\n      for (let c = 0; c < this.size - 1; c++) {\n        if (this.board.grid[r][c].color != 'white' && this.board.grid[r][c].color == this.board.grid[r + 1][c].color && this.board.grid[r][c].color == this.board.grid[r][c + 1].color && this.board.grid[r][c].color == this.board.grid[r + 1][c + 1].color) {\n          // changing all squares in the 2x2 block to a white color to show them being removed\n          this.board.grid[r][c].color = 'white';\n          this.board.grid[r + 1][c].color = 'white';\n          this.board.grid[r][c + 1].color = 'white';\n          this.board.grid[r + 1][c + 1].color = 'white';\n          this.score = this.score + 4; // updates score\n          tempChange = true;\n        }\n      }\n    }\n    if (tempChange == true) {\n      this.count++; // updates count if a block was removed\n    }\n    if (this.board.isWon() == true) {\n      // checks to see if the game is now won\n      this.won = true;\n    }\n  }\n}","map":{"version":3,"names":["config_4x4","config_5x5","config_6x6","configs","Square","constructor","row","column","Board","size","config","grid","Array","from","ninjaSeRow","ninjaRow","ninjaSeColumn","ninjaColumn","toLowerCase","charCodeAt","r","c","color","i","initial","length","isOverlappedWithSquare","isValidMove","verticalChange","horizontalChange","isWon","Model","which","score","count","won","Number","numColumns","board","changeConfiguration","resetConfiguration","moveSquares","newRow","newColumn","removeBlocks","tempChange"],"sources":["C:/Users/aames/Square-Push/src/model/Model.js"],"sourcesContent":["import { config_4x4, config_5x5, config_6x6 } from \"./config\";\r\n\r\n// store configurations\r\nconst configs = [config_5x5, config_4x4, config_6x6]\r\n\r\n/* represents a square on the board */\r\nexport class Square {\r\n    constructor(row, column) {\r\n        this.row = row\r\n        this.column = column\r\n    }\r\n}\r\n\r\n/* represents the game board */\r\nexport class Board {\r\n\r\n    // size is the size of the board\r\n    // config is the configuration of the board\r\n    constructor(size, config) {\r\n        this.size = size // size of game board\r\n        this.config = config // configuration of game board\r\n\r\n        this.grid = Array.from(Array(size), () => new Array(size)); // 2D array representing game board\r\n\r\n        this.ninjaSeRow = this.config.ninjaRow - 1 // Row that the top-left corner of ninja-se is on\r\n        this.ninjaSeColumn = this.config.ninjaColumn.toLowerCase().charCodeAt(0) - 97 // Column that the top-left corner of ninja-se is on\r\n\r\n        //sets up base board\r\n        for (let r = 0; r < size; r++) {\r\n            for (let c = 0; c < size; c++) {\r\n                this.grid[r][c] = new Square(r, c)\r\n                this.grid[r][c].color = 'white'\r\n            }\r\n        }\r\n\r\n        //adds colored squares to board from config file\r\n        for (let i = 0; i < this.config.initial.length; i++) {\r\n            let row = this.config.initial[i][\"row\"] - 1\r\n            let column = this.config.initial[i][\"column\"].toLowerCase().charCodeAt(0) - 97\r\n            let color = this.config.initial[i][\"color\"]\r\n            this.grid[row][column].color = color\r\n        }\r\n\r\n        // how you access a square by its [row][column] location\r\n        // this.grid[2][4]\r\n    }\r\n\r\n    /* return true if ninja-se and a square are at the same spot, or if two squares are at the same spot */\r\n    isOverlappedWithSquare(row, column) {\r\n        if (this.grid[row][column].color != 'white') {\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n\r\n    /* return true if ninja-se can move the intended direction, ninja-se cannot wrap around the board */\r\n    isValidMove(verticalChange, horizontalChange) {\r\n        if (this.ninjaSeRow + verticalChange >= 0 && this.ninjaSeRow + verticalChange < this.size - 1) { //Prevents Ninja-se from moving vertically off the board\r\n            if (this.ninjaSeColumn + horizontalChange >= 0 && this.ninjaSeColumn + horizontalChange < this.size - 1) { //Prevents Ninja-se from moving horizontally off the board\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    /* return true if all colored squares are off the board (game is won) */\r\n    isWon() {\r\n        for (let r = 0; r < this.size; r++) {\r\n            for (let c = 0; c < this.size; c++) {\r\n                if (this.grid[r][c].color != 'white') {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n\r\n}\r\n\r\n/* represents the the logic for the entire model (board, counters, and butttons) */\r\nexport default class Model {\r\n    // info is going to be JSON-encoded puzzle\r\n\r\n    // 'which' is an integer 0..1..2 which selects configuration you can use\r\n    constructor(which) {\r\n        this.config = configs[which] // the configuration selected\r\n        this.score = 0 // integer value for the score value\r\n        this.count = 0 // integer value for the count value\r\n        this.won = false // boolean value on if the game is won\r\n\r\n        this.size = Number(this.config.numColumns) // size of the board\r\n        this.board = new Board(this.size, this.config) // game board within the model\r\n    }\r\n\r\n    /* changes the configuration of the board and resets appropriate values */\r\n    changeConfiguration(which) {\r\n        this.config = configs[which]\r\n        this.won = false\r\n        this.size = Number(this.config.numColumns)\r\n        this.board = new Board(this.size, this.config)\r\n        this.count = 0\r\n        this.score = 0\r\n    }\r\n\r\n    /* resets the configuration of the board to initial layout and resets appropriate values */\r\n    resetConfiguration() {\r\n        this.won = false\r\n        this.size = Number(this.config.numColumns)\r\n        this.board = new Board(this.size, this.config)\r\n        this.count = 0\r\n        this.score = 0\r\n    }\r\n\r\n    /* shifts the squares on the board when they are moved by ninja-se */\r\n    moveSquares(verticalChange, horizontalChange, ninjaSeRow, ninjaSeColumn) {\r\n        if (this.board.isOverlappedWithSquare(ninjaSeRow, ninjaSeColumn)) {\r\n\r\n            let newRow = ninjaSeRow + verticalChange //represents the new row of the item (ninja-se or square) after the vertical change applied to it\r\n            let newColumn = ninjaSeColumn + horizontalChange //represents the new column of the item (ninja-se or square) after the horizontal change applied to it\r\n\r\n            if (newRow == -1) { // wraps a square from the top to the bottom of the board\r\n                newRow = this.size - 1\r\n            } else if (newRow == this.size) { // wraps a square from the bottom to the top of the board\r\n                newRow = 0\r\n            } else if (newColumn == -1) { // wraps a square from the left to the right of the board\r\n                newColumn = this.size - 1\r\n            } else if (newColumn == this.size) { // wraps a sqaure from the right to the left of the board\r\n                newColumn = 0\r\n            }\r\n\r\n            // 1) if the shifted square overlaps with a square we then recursively move the square that is now being overlapped by the vertical and horizontal change\r\n            // 2) once the square finds a location that is empty we then stop the recursion and place that square on the board \r\n            // 3) then we move backwards through the recursion placing all the other squares on the appropriate spots\r\n            if (this.board.isOverlappedWithSquare(newRow, newColumn)) {\r\n                this.moveSquares(verticalChange, horizontalChange, newRow, newColumn)\r\n            }\r\n\r\n            // placing squares on their new spots, and removing them form their old spots\r\n            this.board.grid[newRow][newColumn].color = this.board.grid[ninjaSeRow][ninjaSeColumn].color\r\n            this.board.grid[ninjaSeRow][ninjaSeColumn].color = 'white'\r\n            this.score++\r\n\r\n        }\r\n    }\r\n\r\n\r\n    /* parses whole 2D array looking for 2x2 blocks of the same color and removing them */\r\n    removeBlocks() {\r\n        let tempChange = false\r\n        for (let r = 0; r < this.size - 1; r++) {\r\n            for (let c = 0; c < this.size - 1; c++) {\r\n                if (this.board.grid[r][c].color != 'white'\r\n                    && this.board.grid[r][c].color == this.board.grid[r + 1][c].color\r\n                    && this.board.grid[r][c].color == this.board.grid[r][c + 1].color\r\n                    && this.board.grid[r][c].color == this.board.grid[r + 1][c + 1].color) {\r\n\r\n                    // changing all squares in the 2x2 block to a white color to show them being removed\r\n                    this.board.grid[r][c].color = 'white'\r\n                    this.board.grid[r + 1][c].color = 'white'\r\n                    this.board.grid[r][c + 1].color = 'white'\r\n                    this.board.grid[r + 1][c + 1].color = 'white'\r\n                    this.score = this.score + 4 // updates score\r\n                    tempChange = true\r\n                }\r\n            }\r\n        }\r\n        if (tempChange == true) {\r\n            this.count++ // updates count if a block was removed\r\n        }\r\n        if (this.board.isWon() == true) { // checks to see if the game is now won\r\n            this.won = true\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}